
--myinv

--[[
    Returns the first slot containing item_name.

    When passing 'item_name', you can pass either "wheat_seeds" or 
    "minecraft:wheat_seeds"; the source ("minecraft:", in this case) 
    will be stripped.

    If you're looking for "copper_ore", this will return the first slot 
    in the inventory containing copper_ore, regardless of whether the 
    copper_ore found is "denseores:copper_ore" or 
    "industrycraft:copper_ore".
--]]
function find(item_name)
  item_name = simplify_name(item_name)
  for i = 1,16 do 
    data = turtle.getItemDetail(i)
    if data then
      if simplify_name(data.name) == item_name then return i end
    end
  end
  return false
end

--[[
  Like find(), but this requires that the item_name you pass in be FQ 
  ("minecraft:dirt" rather than just "dirt").  Returns the first slot 
  where that exact item was found.
--]]
function find_exact(item_name)
  if not name_is_fq(item_name) then
    error("Item name " .. item_name .. "is not fully-qualified so can't be used with find_exact()")
  end
  for i = 1,16 do data = turtle.getItemDetail(i)
    if data then
      if data.name == item_name then return i end
    end
  end
  return false
end

--[[
  Returns a table of all slots containing the requested item_name.  
  Name-checking is loose (checks only the item name, not the module 
  source.)
--]]
function find_all(item_name)
  item_name = simplify_name(item_name)
  local slots = {}
  for i = 1,16 do 
    data = turtle.getItemDetail(i)
    if data then
      if simplify_name(data.name) == item_name then table.insert(slots, i) end
    end
  end
  return slots
end

--[[
  Returns a table of all slots containing the requested item_name, using 
  exact name checking (which means that the passed-in item_name must be 
  FQ).
--]]
function find_all_exact(item_name)
  if not name_is_fq(item_name) then
    error("Item name " .. item_name .. "is not fully-qualified so can't be used with find_exact()")
  end
  local slots = {}
  for i = 1,16 do 
    data = turtle.getItemDetail(i)
    if data then
      if data.name == item_name then table.insert(slots, i) end
    end
  end
  return slots
end

--[[
  Finds all inventory slots containing item_name, and attempts to 
  consolidate those items.

  If you pass in a FQ item name (preferred), this will only try to 
  consolidate slots that exactly match your FQ name.
  
  If you pass a non-FQ name, all slots containing an item of that name 
  will be attempted.  This will try to consolidate, eg, "foo:dirt" with 
  "bar:dirt", which won't work.  However, that "not working" shouldn't 
  be an error, it'll just do more checking than should be required.

    Before:
      ---------------------------
      |  20 dirt   |  empty     |
      |  10 dirt   |  50 dirt   |
      ---------------------------
    After
      ---------------------------
      |  64 dirt   |  empty     |
      |  16 dirt   |  empty     |
      ---------------------------

--]]
function consolidate(item_name)
  local slots      = {}
  if name_is_fq(item_name) then slots = find_all_exact(item_name) else slots = find_all(item_name) end
  for i = #slots, 1, -1 do
    turtle.select(slots[i])
    for j = 1, (i-1) do
      if not turtle.transferTo(slots[j]) then break end       -- could not xfer to previous slot (it may be full)
      if not turtle.getItemCount(slots[j]) then break end     -- No items left in selected slot; it's empty.
    end
  end
end

-- Consolidates all items in the inventory
function consolidate_all()
    for i = 1,16 do
        local d = turtle.getItemDetail(i)
        consolidate(d.name)
    end
end

--[[
    Returns true if all inventory slots contain an item.
    Does not check if the item stacks are full, just if there's something in all slots.
--]]
function all_slots_used()
    for i = 1,16 do
        if not turtle.getItemDetail(i) then
            return false
        end
    end
    return true
end


--[[
  Given an item name, returns its simple item name.  If the passed name 
  was already simple, just returns it as-is.

    print simplify_name("dirt")             -- dirt
    print simplify_name("minecraft:dirt")   -- dirt
    print simplify_name("foobar:dirt")      -- dirt

--]]
function simplify_name(item_name)
  local new = string.gsub(item_name, "%w+:", "")
  return new
end

--[[
  Returns true if the passed item_name is FQ.
    if name_is_fq("dirt") then print("yes") else print("no") end              -- no
    if name_is_fq("minecraft:dirt") then print("yes") else print("no") end    -- yes
    if name_is_fq("othermod:dirt") then print("yes") else print("no") end     -- yes
--]]
function name_is_fq(item_name)
  if string.find(item_name,':') then return true else return false end
end


--[[
    Reads x, y, z coords out of a file.  Good for maintaining dumper box coords.
        x, y, z = myinv.get_coords("etc/box.txt")

    The file must contain one coord per line, with specifiers, as:
        x: 12
        y: 342
        z: -220
--]]
function get_coords(f)
    local fh = fs.open(f, 'r')
    local x, y, z
    while true do
        local line = fh.readLine()
        if line == nil then break end
        if string.find(line,'x:') then
            local xs = string.gsub(line, "x:%s+", "")
            x = tonumber(xs)
        elseif string.find(line,'y:') then
            local ys = string.gsub(line, "y:%s+", "")
            y = tonumber(ys)
        elseif string.find(line,'z:') then
            local zs = string.gsub(line, "z:%s+", "")
            z = tonumber(zs)
        end
    end
    fh.close()
    return x, y, z
end

 -- vim: syntax=lua
