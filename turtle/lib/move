
--move rpdxDz77

os.loadAPI("lib/settings")

local x, y, z  = nil, nil, nil
local facing   = nil
local cardinal = {
    ['n'] = { ['right'] = 'e', ['left'] = 'w', ['around'] = 's' },
    ['s'] = { ['right'] = 'w', ['left'] = 'e', ['around'] = 'n' },
    ['e'] = { ['right'] = 's', ['left'] = 'n', ['around'] = 'w' },
    ['w'] = { ['right'] = 'n', ['left'] = 's', ['around'] = 'e' },
}


function init()
    if not test_gps() then return false end
    x, y, z = gps.locate(2)
    if (not x or not y or not z) then error("GPS System is off!") end
    local d = d()
    return true
end

function get_x() return x end
function get_y() return y end
function get_z() return z end

-- Turn around, left, right
function a()
    facing = cardinal[facing]['around']
    turtle.turnLeft()
    return turtle.turnLeft()
end
function l()
    facing = cardinal[facing]['left']
    return turtle.turnLeft()
end
function r()
    facing = cardinal[facing]['right']
    return turtle.turnRight()
end

-- Face a cardinal direction
function face_n()
    local d = d()
    if d == 'e' then l() elseif d == 's' then a() elseif d == 'w' then r() end
    return true
end
function face_e()
    local d = d()
    if d == 'n' then r() elseif d == 's' then l() elseif d == 'w' then a() end
    return true
end
function face_s()
    local d = d()
    if d == 'n' then a() elseif d == 'e' then r() elseif d == 'w' then l() end
    return true
end
function face_w()
    local d = d()
    if d == 'n' then l() elseif d == 'e' then a() elseif d == 's' then r() end
    return true
end
function face(dir)
    if dir == 'n' then face_n() 
        elseif dir == 'e' then face_e() 
        elseif dir == 's' then face_s() 
        elseif dir == 'w' then face_w()
        else 
            error("Dir must be 'n', 's', 'e', or 'w'.")
            return false
    end
    return true
end

--[[
    Get the direction the turtle is facing theoretically.
    Returns one of 'n', 'e', 's', 'w' on success, false on failure.
--]]
function d()
    if not facing then
        if not test_gps() then return false end
        facing = find_direction()
    end
    return facing
end


--[[
    Get the direction the turtle is facing empirically.
    If the turtle can not move laterally, this function cannot determine its 
    facing direction and will fail.

    Returns one of 'n', 'e', 's', 'w' on success, false on failure.
--]]
function find_direction()
    local startx, starty, startz = gps.locate(2)
    local endx, endy, endz       = nil, nil, nil
    local turns                  = 0

    while not endx do
        success, data = turtle.inspect()
        --[[
            false success means the plot in front of the turtle is empty and he can move into it.
            The turtle can move through both types of both lava and water.
        --]]
        if (success and (data.name ~= 'minecraft:water' and data.name ~= 'minecraft:flowing_water' and data.name ~= "minecraft:lava" and data.name ~= "minecraft:flowing_lava") ) then
            turtle.turnRight()
            turns = turns + 1
            if turns>3 then
                error("I cannot move, so I can't determine direction.")
                return false
            end
        else
            if not turtle.forward() then error("I should have been able to move forward but I could not.") end
            endx, endy, endz = gps.locate(2)
            turtle.back()
        end
    end


    if endx ~= startx then
        if endx > startx then facing = 'e' else facing = 'w' end
    else
        if endz > startz then facing = 's' else facing = 'n' end
    end

    -- Turn back the way we were originally facing
    for i = 1,turns do l() end
    return facing
end

--[[
    Determines if the GPS system working and in range.
    Returns true or false.
--]]
function test_gps()
    local t1, t2, t3 = gps.locate(2)
    if t1 then return true else return false end
end

--[[
  Returns the turtle to its set home.
  First ascends to height h (defaults 
  to 100) to attempt to avoid 
  obstacles.
  bin/set_home must be run once before 
  this will work.
  Returns true or false.

  Fly up to y==100 then head to home_x, 
  home_y, home_z
  > move.go_home()

  Fly up to y==50 then head to home_x, 
  home_y, home_z
  > move.go_home(50)

  Fly up to y==50 then head to 
  origin_x, origin_y, origin_z
  > move.go_home(50, "origin")

--]]
function go_home(height, name)
    local height = height or 100           -- a reasonable wag
    local name   = name or 'home'
    local hx     = settings.get('home_x')
    local hy     = settings.get('home_y')
    local hz     = settings.get('home_z')
    if not hx or not hy or not hz then
        error("You must run bin/set_home first.")
        return false
    end
    goto(hx, hy, hz, height)
    return true
end

--[[
    Returns the turtle one block above its set box, and empties the turtle's 
    entire inventory into that box.
    First ascends to height h (defaults to 100) to attempt to avoid obstacles.
    bin/find_box must be run once before this will work.
    Returns true or false.
--]]
function return_to_box(h)
    local h = h or 100               -- a fairly reasonable wag
    local bx = settings.get('box_x')
    local by = settings.get('box_y')
    local bz = settings.get('box_z')
    if not bx or not by or not bz then
        error("You must run bin/find_box first.")
        return false
    end

    goto(bx, by+1, bz, h)
    for i = 1,16 do
        turtle.select(i)
        local s, d = turtle.getItemDetail()
        if s then
            if not turtle.dropDown() then box_is_full = true end
        end
    end
    return (not box_is_full)
end


--[[
    Move in a given direction (up, dn, fd, bk) a given number of times 
    (defaults to 1).
    If passed a true value as the second argument, will attempt to force its 
    way in the given direction.
    "Force" means it will attempt to both dig and attack in the given 
    direction if it is unable to move that way after the first attempt.
--]]
function up(cnt,force)
	local cnt   = cnt or 1
    local force = force or false
    local wait  = 0
	for i=1,cnt do
        while not turtle.up() do
            if wait == 5 then
                return i - 1
            end
            if force then
                turtle.digUp()
                if turtle.attackUp() then sleep(0.25) end
                turtle.attackUp()
            end
            wait = wait + 1
            --sleep(1)
		end
    y = y + 1
    end
	return cnt
end
function dn(cnt,force)
	local cnt   = cnt or 1
    local force = force or false
    local wait  = 0
	for i=1,cnt do
        while not turtle.down() do
            if wait == 5 then
                return i - 1
            end
            if force then
                turtle.digDown()
                if turtle.attackDown() then sleep(0.25) end
                turtle.attackDown()
            end
            wait = wait + 1
            --sleep(1)
		end
    end
    y = y - 1
	return cnt
end
function fd(cnt,force)
	local cnt   = cnt or 1
    local force = force or false
    local wait  = 0
	for i=1,cnt do
        while not turtle.forward() do
            if wait == 5 then
                return i - 1
            end
            if force then
                turtle.dig()
                if turtle.attack() then sleep(0.25) end
                turtle.attack()
            end
            wait = wait + 1
            --sleep(0.25)
		end
    end
    if facing == 'n' then z = z-1
        elseif facing == 'e' then x = x+1
        elseif facing == 's' then z = z+1
        elseif facing == 'w' then x = x-1
    end
	return cnt
end
function bk(cnt,force)
	local cnt   = cnt or 1
    local force = force or false
    local wait  = 0
	for i=1,cnt do
        while not turtle.back() do
            if wait == 5 then
                return i - 1
            end
            if force then
                a()
                turtle.dig()
                if turtle.attack() then sleep(0.25) end
                turtle.attack()
                a()
            end
            wait = wait + 1
            --sleep(1)
    	end
    end
    if facing == 'n' then z = z+1
        elseif facing == 'e' then x = x-1
        elseif facing == 's' then z = z-1
        elseif facing == 'w' then x = x+1
    end
	return cnt
end

--[[
    Go to a specific point.
        goto(x, y, z, height, force)

    Height arg is an optional int.  If passed, the turtle first ascends to 
    that height to attempt to avoid obstacles.

    Force arg is an optional boolean.  If true, the turtle will try to force 
    its way through obstacles by digging and/or attacking.

    gotoX(), gotoY(), and gotoZ() generally won't be interesting to the user.
--]]
function gotoX(toX,force)
    if toX == nil then error("No coordinate specified.",2) end
    local force = force or false
    if x < toX then
        face_e()
    else
        face_w()
    end

    while x ~= toX do
        fd(1,force)
	end
end
function gotoY(toY,force)
    if toY == nil then error("No coordinate specified.",2) end
    local force = force or false
    if y < toY then
		move = up
		dig = turtle.digUp
	elseif y > toY then
		move = dn
		dig = turtle.digDown
	end
	
	while y ~= toY do move(1,force) end
end
function gotoZ(toZ,force)
    if toZ == nil then error("No coordinate specified.",2) end
    local force = force or false
    if z < toZ then face_s() else face_n() end
    while z ~= toZ do fd(1, force) end
end
function goto(toX, toY, toZ, height, force)
    local toX = toX or x
    local toY = toY or y
    local toZ = toZ or z

    if height then gotoY(height, true) end

    gotoX(toX, force)
    gotoZ(toZ, force)
    gotoY(toY, force)
end



init()
sleep(0.5)

 -- vim: syntax=lua
