
--dig_cube


--[[
    Still need to test this with odd rows and odd cols, and then with odd and even and then with
    even and odd.
--]]


--[[
    Assumes its starting point is the 
    SW corner of a cubic rectangle to 
    dig out.

    Defaults to an 8x8 square.  You can 
    determine the length and width at 
    the command line:
      > bin/dig_cube 4 8

    ...That will dig forward 4 blocks, 
    then right 8, forming a rectangle.

    When its inventory fills up, it'll 
    go back to its box to empty out (so 
    make sure you've run bin/find_box 
    first).

    When its job is complete, it'll 
    head back to its home, so be sure 
    to also run bin/set_home first.
--]]


os.loadAPI("lib/inv")
os.loadAPI("lib/move")
os.loadAPI("lib/settings")

local args = {...}

---------------------------------------
-- EDIT BELOW

--[[
    Height (cols), width (rows), and 
    depth (depth) of the rectangle to 
    dig.
--]]
local cols  = tonumber(args[1]) or 8
local rows  = tonumber(args[2]) or 8

-- relative to the turtle's start point
local depth = tonumber(args[3]) or 100

--[[
    Absolute height to fly up to 
    before returning to the box.  
    Should be high enough to fly above 
    any obstacles between the pit and 
    box.
--]]
local highest = tonumber(args[4]) or 70

-- END EDITS
---------------------------------------

--[[
    Neither box nor home coords are used in this script; go_home() and 
    return_to_box are both in the move library.
    So we're just sanity-checking that the coords are set now so we don't get 
    halfway through digging before realizing we don't have a home or box.
--]]
-- Coords of the box we'll dump our inv to
local bx, by, bz = settings.get('box_x'), settings.get('box_y'), settings.get('box_z')
if not bx or not by or not bz then
    error("You must call bin/find_box first.")
    return
end
-- Coords of out home spot
local hx, hy, hz = settings.get('home_x'), settings.get('home_y'), settings.get('home_z')
if not hx or not hy or not hz then
    error("You must call bin/set_home first.")
    return
end

-- When/if these become true we'll return to the box and quit.
local hit_bedrock = false
local box_is_full = false




--[[
    Return to 1 plot above the box, 
    dump our inv into it.
    Returns true on success, false if the box is full.
--]]
function return_to_box()
    move.goto(bx, by+1, bz, highest)
    for i = 1,16 do
        turtle.select(i)
        local s, d = turtle.getItemDetail()
        if s then
            if not turtle.dropDown() then box_is_full = true end
        end
    end
    return (not box_is_full)
end

--[[
    Goes to the box, dumps 
    ourinventory, then returns back 
    where it started.
--]]
function dump_inv_and_return()
    local rx, ry, rz = gps.locate(2)
    local rd         = move.d()

    return_to_box()
    if box_is_full then
        error("Our dumping box is full!")
        return false
    else
        if not rx or not ry or not rz then
            error("Bottom of pit was out of GPS range; can't return!")
            return            -- my error message was lying!
        end
        move.goto(rx, ry, rz, highest)
        move.face(rd)
        return true
    end
end

--[[
    Moves forward one slot, digging if 
    necessary.
    Automatically goes back to the box 
    to dump inventory when needed.
    Returns true on success, false if 
    the box is full or if we hit 
    bedrock.  
--]]
function dig_move_forward()
    local s,d = turtle.inspect()
    if (s and d.name == 'minecraft:bedrock') then hit_bedrock = true end
    move.fd(1, true)
    if inv.all_slots_used() then inv.consolidate_all() end
    if inv.all_slots_used() then dump_inv_and_return() end
    if (hit_bedrock or box_is_full) then
        if hit_bedrock then
            print("We've hit bedrock.")
        else
            print("Our inventory box is full.")
        end
        return_to_box()
        return false
    end
    return true
end
function dig_move_down()
    local s,d = turtle.inspectDown()
    if (s and d.name == 'minecraft:bedrock') then hit_bedrock = true end
    move.dn(1, true)
    if inv.all_slots_used() then inv.consolidate_all() end
    if inv.all_slots_used() then dump_inv_and_return() end
    if (hit_bedrock or box_is_full) then
        if hit_bedrock then
            print("We've hit bedrock.")
        else
            print("Our inventory box is full.")
        end
        return_to_box()
        return false
    end
    return true
end


local startx, starty, startz = gps.locate(2)
local rdepth                 = starty - depth
rows                         = rows - 1
local col_cnt                = 0
local curr_depth             = starty
while curr_depth  >= rdepth do
    for i = 1,cols do
        for j = 1,rows do
            if not dig_move_forward() then return end
        end
        col_cnt = col_cnt + 1

        --[[
            Make sure we're actually where we think we should be or cowardly 
            bail out.
        --]]
        if move.test_gps() then
            local x, y, z = gps.locate(2)
            if x ~= move.get_x() or y ~= move.get_y() or z ~= move.get_z() then
                print("Shit I don't know how we got here.")
                print("Bailing back home.")
                return_to_box()
                go_home()
                return
            end
        else
            error("GPS is off or we're out of range")
            return_to_box()
            go_home()
            return
        end

        if col_cnt < cols then
            if col_cnt % 2 == 1 then
                move.r()
                if not dig_move_forward() then return end
                move.r()
            else
                move.l()
                if not dig_move_forward() then return end
                move.l()
            end
        else
            if col_cnt % 2 == 1 then move.l() move.l() else move.r() end
        end
    end

    col_cnt = 0
    curr_depth = curr_depth - 1
    if curr_depth >= rdepth then dig_move_down() end
end

return_to_box()
go_home()
print("Ready for next mission, boss!")


 -- vim: syntax=lua
