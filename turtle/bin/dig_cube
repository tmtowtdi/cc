
--dig_cube


--[[
    Still need to test this with odd rows and odd cols, and then with odd and even and then with
    even and odd.
--]]


--[[
    Assumes its starting point is the 
    SW corner of a cubic rectangle to 
    dig out.

    Defaults to an 8x8 square.  You can 
    determine the length and width at 
    the command line:
      > bin/dig_cube 4 8

    ...That will dig forward 4 blocks, 
    then right 8, forming a rectangle.

    When its inventory fills up, it'll 
    go back to its box to empty out (so 
    make sure you've run bin/find_box 
    first).

    When its job is complete, it'll 
    head back to its home, so be sure 
    to also run bin/set_home first.
--]]


os.loadAPI("lib/inv")
os.loadAPI("lib/move")
os.loadAPI("lib/settings")

local args = {...}

---------------------------------------
-- EDIT BELOW

--[[
    Height (cols), width (rows), and 
    depth (depth) of the rectangle to 
    dig.
--]]
local cols  = tonumber(args[1]) or 8
local rows  = tonumber(args[2]) or 8

-- relative to the turtle's start point
local depth = tonumber(args[3]) or 100

--[[
    Absolute height to fly up to 
    before returning to the box.  
    Should be high enough to fly above 
    any obstacles between the pit and 
    box.
--]]
local highest = tonumber(args[4]) or 70

-- END EDITS
---------------------------------------

if not move.has_home('home') or not move.has_box('box') then
  print("You must call both bin/find_box and.")
  print("bin/set_home before running this.")
  return
end





--[[
  Goes to the box, dumps our inventory, 
  then returns back where it started.
--]]
function dump_inv_and_return()
  local rx, ry, rz = gps.locate(2)
  local rd         = move.d()

  if not move.return_to_box() then
    if not rx or not ry or not rz then
      --GPS system might must be out of range.  Fly up and try again.
      move.gotoY(highest, true)
      if not move.return_to_box() then
        error("Bottom of pit was out of GPS range; can't return!")
        return false
      end
    end
  end

  if not move.dump_inv("dn") then
    error("Our dumping box is full.  Heading home.")
    return false
  end

  move.goto(rx, ry, rz, highest)
  move.face(rd)
  return true
end

--[[
    Moves forward one slot, digging if 
    necessary.
    Automatically goes back to the box 
    to dump inventory when needed.

    If we hit bedrock, dumps inventory 
    in box and goes home.

    If inventory box is full, goes 
    home.
    
    Returns true or false on success or 
    fail.
--]]
function dig_move_forward()
  local s,d = turtle.inspect()
  if (s and d.name == 'minecraft:bedrock') then
    error("Hit bedrock - done.")
    move.return_to_box()
    move.dump_inv("dn")
    move.go_home(highest)
  end
  move.fd(1, true)
  if inv.all_slots_used() then inv.consolidate_all() end
  if inv.all_slots_used() then
    if not dump_inv_and_return() then
      print("Our inventory box is full.")
      move.go_home(highest)
      return false
    end
  end
  return true
end

function dig_move_down()
  local s,d = turtle.inspectDown()
  if (s and d.name == 'minecraft:bedrock') then
    error("Hit bedrock - done.")
    move.return_to_box()
    move.dump_inv("dn")
    move.go_home(highest)
  end
  move.dn(1, true)
  if inv.all_slots_used() then inv.consolidate_all() end
  if inv.all_slots_used() then
    if not dump_inv_and_return() then
      print("Our inventory box is full.")
      move.go_home(highest)
      return false
    end
  end
  return true
end






local startx, starty, startz = gps.locate(2)
local rdepth                 = starty - depth
rows                         = rows - 1
local col_cnt                = 0
local curr_depth             = starty
while curr_depth  >= rdepth do
    for i = 1,cols do
        for j = 1,rows do
            if not dig_move_forward() then return end
        end
        col_cnt = col_cnt + 1

        --[[
            Make sure we're actually where we think we should be or cowardly 
            bail out.
        --]]
        if move.test_gps() then
            local x, y, z = gps.locate(2)
            if x ~= move.get_x() or y ~= move.get_y() or z ~= move.get_z() then
                print("Shit I don't know how we got here.")
                print("Bailing back home.")
                move.return_to_box(highest)
                move.dump_inv("dn")
                move.go_home(highest)
                return
            end
        else
            error("GPS is off or we're out of range")
            move.return_to_box(highest)
            move.dump_inv("dn")
            move.go_home(highest)
            return
        end

        if col_cnt < cols then
            if col_cnt % 2 == 1 then
                move.r()
                if not dig_move_forward() then return end
                move.r()
            else
                move.l()
                if not dig_move_forward() then return end
                move.l()
            end
        else
            if col_cnt % 2 == 1 then move.l() move.l() else move.r() end
        end
    end

    col_cnt = 0
    curr_depth = curr_depth - 1
    if curr_depth >= rdepth then dig_move_down() end
end

move.return_to_box(highest)
move.dump_inv("dn")
move.go_home(highest)
print("Ready for next mission, boss!")


 -- vim: syntax=lua
